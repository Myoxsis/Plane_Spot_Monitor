import { NextRequest, NextResponse } from 'next/server';import { prisma } from '@/lib/db';export async function GET(req:NextRequest){const {searchParams}=new URL(req.url);const airport=(searchParams.get('airport')||'CDG').toUpperCase();const direction=(searchParams.get('direction')||'departures').toLowerCase();const minScore=parseInt(searchParams.get('minScore')||'0',10);const maxScore=searchParams.get('maxScore')?parseInt(searchParams.get('maxScore')!,10):undefined;const from=searchParams.get('from')?new Date(searchParams.get('from')!):undefined;const to=searchParams.get('to')?new Date(searchParams.get('to')!):undefined;const timeField=(searchParams.get('timeField')||'extracted') as 'extracted'|'scheduled'|'actual';const airline=searchParams.get('airline')||undefined;const modelCode=searchParams.get('modelCode')||undefined;const registration=searchParams.get('registration')||undefined;const origin=searchParams.get('origin')||undefined;const destination=searchParams.get('destination')||undefined;const label=(searchParams.get('label')||'all') as 'all'|'exceptional'|'notable'|'normal';const hasLivery=searchParams.get('hasLivery')==='true'?true:searchParams.get('hasLivery')==='false'?false:undefined;const liveryContains=searchParams.get('liveryContains')||undefined;const reasonsContains=searchParams.get('reasonsContains')||undefined;const timeWhere=(()=>{if(!(from||to)) return undefined as any;if(timeField==='scheduled'){return{OR:[{scheduledDepartureUtc:{...(from?{gte:from}:{}) , ...(to?{lte:to}:{})}},{scheduledArrivalUtc:{...(from?{gte:from}:{}) , ...(to?{lte:to}:{})}}]}}if(timeField==='actual'){return{OR:[{actualDepartureUtc:{...(from?{gte:from}:{}) , ...(to?{lte:to}:{})}},{actualArrivalUtc:{...(from?{gte:from}:{}) , ...(to?{lte:to}:{})}}]}}return{extractedAtUtc:{...(from?{gte:from}:{}) , ...(to?{lte:to}:{})}}})();const where:any={airport,direction,...(timeWhere||{}),airline:airline?{contains:airline}:undefined,registration:registration?{contains:registration}:undefined,modelCode:modelCode?{equals:modelCode}:undefined,originCode:origin?{equals:origin}:undefined,destinationCode:destination?{equals:destination}:undefined,liveryInfo:hasLivery===undefined?undefined:(hasLivery?{not:null}:null as any),score:(label!=='all'||minScore>0||maxScore!==undefined||reasonsContains)?{is:{...(label!=='all'?{label}:{}),...(minScore>0?{score:{gte:minScore}}:{}),...(maxScore!==undefined?{score:{lte:maxScore}}:{}),...(reasonsContains?{reasons:{contains:reasonsContains}}:{})}}:undefined};Object.keys(where).forEach(k=> (where as any)[k]===undefined && delete (where as any)[k]);const itemsRaw=await prisma.movement.findMany({where,orderBy:{extractedAtUtc:'desc'},include:{score:{select:{score:true,label:true,reasons:true}}},take:500});let items=itemsRaw.map(it=>({...it,score:it.score?{...it.score,reasons:(()=>{try{return JSON.parse(it.score.reasons as any)}catch{return[]}})()}:null}));if(liveryContains){const needle=liveryContains.toLowerCase();items=items.filter(it=> (it.liveryInfo||'').toLowerCase().includes(needle))}return NextResponse.json({airport,direction,count:items.length,items})}
